/*!
 * Universal, Accessible Video Player
 * (c) 2026 Matthias Peltzer
 * Released under GPL-2.0-or-later License
 */
var e=class e{constructor(e="vidply"){this.namespace=e,this.storage=this.isStorageAvailable()?localStorage:null}isStorageAvailable(){try{const e="__storage_test__";return localStorage.setItem(e,e),localStorage.removeItem(e),!0}catch(e){return!1}}getKey(e){return`${this.namespace}_${e}`}set(e,t){if(!this.storage)return!1;try{const r=this.getKey(e);return this.storage.setItem(r,JSON.stringify(t)),!0}catch(e){return console.warn("Failed to save to localStorage:",e),!1}}get(e,t=null){if(!this.storage)return t;try{const r=this.getKey(e),s=this.storage.getItem(r);return s?JSON.parse(s):t}catch(e){return console.warn("Failed to read from localStorage:",e),t}}remove(e){if(!this.storage)return!1;try{const t=this.getKey(e);return this.storage.removeItem(t),!0}catch(e){return console.warn("Failed to remove from localStorage:",e),!1}}clear(){if(!this.storage)return!1;try{return Object.keys(this.storage).forEach(e=>{e.startsWith(this.namespace)&&this.storage.removeItem(e)}),!0}catch(e){return console.warn("Failed to clear localStorage:",e),!1}}saveTranscriptPreferences(e){return this.set("transcript_preferences",e)}getTranscriptPreferences(){return this.get("transcript_preferences",null)}saveCaptionPreferences(e){return this.set("caption_preferences",e)}getCaptionPreferences(){return this.get("caption_preferences",null)}savePlayerPreferences(e){return this.set("player_preferences",e)}getPlayerPreferences(){return this.get("player_preferences",null)}saveSignLanguagePreferences(e){return this.set("sign_language_preferences",e)}getSignLanguagePreferences(){return this.get("sign_language_preferences",null)}static MAX_WATCH_PROGRESS_ENTRIES=100;saveWatchProgress(t,r,s){if(!t||!s||s<=0)return!1;const a=this.get("watch_progress",{});a[t]={currentTime:r,duration:s,percentage:r/s*100,updatedAt:Date.now()};const n=Object.entries(a);if(n.length>e.MAX_WATCH_PROGRESS_ENTRIES){n.sort((e,t)=>e[1].updatedAt-t[1].updatedAt);const t=n.length-e.MAX_WATCH_PROGRESS_ENTRIES;for(let e=0;e<t;e++)delete a[n[e][0]]}return this.set("watch_progress",a)}getWatchProgress(e){return e&&this.get("watch_progress",{})[e]||null}clearWatchProgress(e){if(!e)return!1;const t=this.get("watch_progress",{});return!t[e]||(delete t[e],this.set("watch_progress",t))}};export{e as StorageManager};